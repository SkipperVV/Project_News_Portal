Проект News Portal
В ходе этого модуля вы шаг за шагом изучали принципы построения баз данных и создания моделей, а также 
размышляли над собственным приложением News Portal. Итоговое задание этого модуля заключается в создании 
этого приложения (пока что только моделей). Таким образом получится базовый проект, в котором будут выполняться 
задания следующих модулей.

Что в нём должно быть?

Модель Author
Модель, содержащая объекты всех авторов.
Имеет следующие поля:
cвязь «один к одному» с встроенной моделью пользователей User;
рейтинг пользователя. Ниже будет дано описание того, как этот рейтинг можно посчитать.

Модель Category
Категории новостей/статей — темы, которые они отражают (спорт, политика, образование и т. д.). Имеет единственное поле: 
название категории. Поле должно быть уникальным (в определении поля необходимо написать параметр unique = True).

Модель Post
Эта модель должна содержать в себе статьи и новости, которые создают пользователи. Каждый объект может иметь одну или 
несколько категорий.
Соответственно, модель должна включать следующие поля:
связь «один ко многим» с моделью Author;
поле с выбором — «статья» или «новость»;
автоматически добавляемая дата и время создания;
связь «многие ко многим» с моделью Category (с дополнительной моделью PostCategory);
заголовок статьи/новости;
текст статьи/новости;
рейтинг статьи/новости.

Модель PostCategory
Промежуточная модель для связи «многие ко многим»:
связь «один ко многим» с моделью Post;
связь «один ко многим» с моделью Category.

Модель Comment
Под каждой новостью/статьёй можно оставлять комментарии, поэтому необходимо организовать их способ хранения тоже.
Модель будет иметь следующие поля:
связь «один ко многим» с моделью Post;
связь «один ко многим» со встроенной моделью User (комментарии может оставить любой пользователь, необязательно автор);
текст комментария;
дата и время создания комментария;
рейтинг комментария.
Эти модели должны также реализовать методы:

Методы like() и dislike() в моделях Comment и Post, которые увеличивают/уменьшают рейтинг на единицу.
Метод preview() модели Post, который возвращает начало статьи (предварительный просмотр) длиной 124 символа и добавляет 
многоточие в конце.
Метод update_rating() модели Author, который обновляет рейтинг пользователя, переданный в аргумент этого метода.
Он состоит из следующего:
суммарный рейтинг каждой статьи автора умножается на 3;
суммарный рейтинг всех комментариев автора;
суммарный рейтинг всех комментариев к статьям автора.
В качестве результата задания подготовьте файл, в котором напишете список всех команд, запускаемых в Django shell.

Что вы должны сделать в консоли Django?

Создать двух пользователей (с помощью метода User.objects.create_user('username')).
Создать два объекта модели Author, связанные с пользователями.
Добавить 4 категории в модель Category.
Добавить 2 статьи и 1 новость.
Присвоить им категории (как минимум в одной статье/новости должно быть не меньше 2 категорий).
Создать как минимум 4 комментария к разным объектам модели Post (в каждом объекте должен быть как минимум один комментарий).
Применяя функции like() и dislike() к статьям/новостям и комментариям, скорректировать рейтинги этих объектов.
Обновить рейтинги пользователей.
-----------------
Вывести username и рейтинг лучшего пользователя (применяя сортировку и возвращая поля первого объекта).
Вывести дату добавления, username автора, рейтинг, заголовок и превью лучшей статьи, основываясь на лайках/дислайках к 
этой статье.
Вывести все комментарии (дата, пользователь, рейтинг, текст) к этой статье.
Созданное вами приложение вместе с файлом с командами необходимо загрузить в git-репозиторий.
**********************************************************************

Доработайте своё новостное приложение:

Сделайте новую страничку с адресом /news/, на которой должен выводиться список всех новостей.
Сделайте отдельную страничку для конкретной новости по адресу /news/<id новости>.
Все странички должны быть частью основного шаблона default.html.

если мы считаем слово «редиска» ругательством, то из предложения «Нехороший человек — редиска!»
после применения фильтра должно получиться «Нехороший человек — р******!»
Дополнительно попробуйте сделать проверку, чтобы фильтр цензурирования применялся только к
переменным строкового типа. Иными словами, если фильтр применяется не к строке, разработчик получает ошибку.
Написать собственный фильтр censor, который заменяет буквы нежелательных слов в заголовках и текстах статей на символ «*».
---------------------------------
Доработайте ваш сайт с новостями:

Добавьте страничку /news/search.
На ней должна быть реализована возможность пользователя искать новости по определённым критериям.

Критерии должны быть следующие:
позже какой-либо даты;
по названию;
по имени пользователя автора;
всё вместе.
Добавьте постраничный вывод на основной странице новостей, чтобы на одной странице было не больше 10 новостей,
и были видны номера лишь ближайших страниц, а также возможность перехода к первой или последней странице.
---------------------------------------------
Усовершенствовать ваш новостной портал. Добавить постраничный вывод и отдельную страницу с поиском /search/,
чтобы пользователь мог сортировать новости по дате и имени автора.

Необходимо иметь возможность создавать новые новости и статьи не только из админки, но и в самом приложении.
Для такой возможности необходимо создать модельные формы.
Необходимо добавить на сайт с помощью дженериков новые страницы /news/add/, а также /news/<int:pk>/edit/.
На этих страницах пользователь может добавить или редактировать новости.

Добавьте страницу удаления новостей /news/<int:pk>/delete/. На ней после подтверждения пользователь может удалить страницу с новостью.

------3/8  D8.3. Доступ к страницам сайта---------------------------------------
UpdateView. Реализуйте для него проверку наличия аутентификации с помощью миксина. В файле настроек проекта добавьте адрес, по которому
Django будет перенаправлять пользователей после успешного входа в систему.

------3/8   D8.4. Возможности регистрации в Django---------------------------------------
Используя только пакет allauth, реализуйте в своём приложении News Portal возможность входа в систему, а также
регистрации по почте или через Google-аккаунт. В файле настроек добавьте адрес на страницу входа,
по которому перенаправится неавторизованный пользователь при попытке перейти на защищённые страницы.

Шаги:
pip install django-allauth

TEMPLATES + 'django.template.context_processors.request',

AUTHENTICATION_BACKENDS = [
    # Needed to login by username in Django admin, regardless of `allauth`
    'django.contrib.auth.backends.ModelBackend',
    # `allauth` specific authentication methods, such as login by e-mail
    'allauth.account.auth_backends.AuthenticationBackend',
]
INSTALLED_APPS +
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    # ... include the providers you want to enable:
    'allauth.socialaccount.providers.google',

LOGIN_URL = '/accounts/login/'

SITE_ID = 1

ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_UNIQUE_EMAIL = True
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_EMAIL_VERIFICATION = 'none'

'allauth.account.middleware.AccountMiddleware'
must be added to settings.MIDDLEWARE

После завершения этих настроек, мы должны заглянуть в файл конфигурации URL и внести изменения в нём:

urlpatterns = [
+    path('sign/', include('sign.urls')),

написать базовый шаблон templates/account/base.html
<!DOCTYPE html>
<html>
    <head>
        <title>{% block head_title %}Registration & Login{% endblock head_title %}</title>
    </head>
    <body>
        {% block body %}
        {% block content %}
        {% endblock content %}
        {% endblock body %}
        {% block extra_body %}
        {% endblock extra_body %}
    </body>
</html>

После модификации файла настроек обязательно необходимо выполнить миграцию.
python manage.py migrate

Регистрация посредством провайдера
В случае регистрации и входа через провайдер необходимо проделать ещё некоторые действия.
Для начала нужно войти в панель администратора и перейти на вкладку Sites:
Далее необходимо перейти на страницу единственного объекта и отредактировать следующим образом:
Domain name: 127.0.0.1
Сохраните изменения.

Далее необходимо настроить API Google для работы с вашим сервисом. Перейдите на страницу разработчиков.
Вам будет предложено создать проект.
Сделал. Ссылка:
https://console.cloud.google.com/apis/dashboard?pli=1&project=myproject-399913&supportedpurview=project

После чего вам необходимо получить Client ID.
Для этого перейдите по следующей ссылке: <+Enable APIS and Services>
Подключите следующее API: IAM Service Account Credentials API (найти поисковиком)
Enable
Credentials (Реквизиты для входа)
Create OAuth client ID
Client ID: 564458227682-tp5a4ooq35lnssoh6rmrrk0r9qr2sgch.apps.googleusercontent.com
Client secret: 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
(Моя Страница credentials: https://console.cloud.google.com/apis/credentials?project=myproject-399913
<+Create Credentials>)

Вы увидите окно с идентификатором клиента и секретным ключом. Не закрывайте это окно.
Откройте панель администратора на странице:
http://127.0.0.1:8000/admin/socialaccount/socialapp/
и создайте новое приложение Social applications.

Название, как и провайдер, можно вписать Google. В поля Client ID и Secret Key введите полученные
на консоли разработчиков строки с идентификатором и ключом и сохраните изменения на панели администратора.

После чего проверьте работоспособность путём попытки авторизации через Google на
странице авторизации вашего свежесозданного сайта. Если все действия выполнены верно,
вам должно быть предложено завершить регистрацию.
------------
Ссылка на созданный сайт Google
https://console.cloud.google.com/apis/credentials?project=myproject-399913
---------------------------
При помощи панели администратора Django добавьте две группы common и authors для всех пользователей и авторов соответственно.
При регистрации пользователь должен автоматически добавляться в группу common. Добавьте кнопку «Стать автором»,
при нажатии на которую, пользователь добавляется в группу authors.
------------
pip install django-allauth
в файле настроек нужно внести следующие изменения:
# Specify the context processors as follows:
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                # Already defined Django-related contexts here

                # `allauth` needs this from django
                'django.template.context_processors.request',
            ],
        },
    },
]

AUTHENTICATION_BACKENDS = [
    ...
    # Needed to login by username in Django admin, regardless of `allauth`
    'django.contrib.auth.backends.ModelBackend',

    # `allauth` specific authentication methods, such as login by e-mail
    'allauth.account.auth_backends.AuthenticationBackend',
]

INSTALLED_APPS = [
    ...
    # The following apps are required:
    'django.contrib.auth',
    'django.contrib.messages',
    'django.contrib.sites',

    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    # ... include the providers you want to enable:
    'allauth.socialaccount.providers.google',
]


LOGIN_URL = '/accounts/login/'

SITE_ID = 1

Далее нам необходимо добавить бэкенды аутентификации: встроенный бэкенд Django, реализующий аутентификацию по username,
а также бэкенд аутентификации, предоставленный пакетом allauth. Грубо говоря, нам нужно «включить» аутентификацию
как по username, так и специфичную по email или сервис-провайдеру.

Начнём с регистрации по электронной почте.
В файл настроек проекта мы должны внести дополнительные параметры:

ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_UNIQUE_EMAIL = True
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_EMAIL_VERIFICATION = 'none'

конфигурации URL и внести изменения в нём:

from django.contrib import admin
from django.urls import path
from django.urls import include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('protect.urls')),
    path('sign/', include('sign.urls')),
    path('accounts/', include('allauth.urls')),
]
После модификации файла настроек обязательно необходимо выполнить миграцию.
....
**************************************
В классе-представлении редактирования профиля добавить проверку аутентификации.
Выполнить необходимые настройки пакета allauth в файле конфигурации.
В файле конфигурации определить адрес для перенаправления на страницу входа в систему и адрес перенаправления после успешного входа.
Реализовать шаблон с формой входа в систему и выполнить настройку конфигурации URL.
Реализовать шаблон страницы регистрации пользователей.
Реализовать возможность регистрации через Google-аккаунт.
Создать группы common и authors.
Реализовать автоматическое добавление новых пользователей в группу common.
Создать возможность стать автором (быть добавленным в группу authors).
Для группы authors предоставить права создания и редактирования объектов модели Post (новостей и статей).
В классах-представлениях добавления и редактирования новостей и статей добавить проверку прав доступа.
Исходный код залить в git-репозиторий.
***************************************
Добавьте пользователю возможность подписываться на рассылку новостей в какой-либо категории. 
Для этого добавьте поле subscribers (соотношение manytomany), в которое будут записываться пользователи, 
подписанные на обновления в данной категории. И при добавлении новости из этой категории пользователю на 
email, указанный при регистрации, приходит письмо с HTML-кодом заголовка и первых 50 символов текста статьи.

В теме письма должен быть сам заголовок статьи. Текст состоит из вышеуказанного HTML и текста: 
«Здравствуй, username. Новая статья в твоём любимом разделе!».

На самом сайте должна быть возможность пользователю подписаться на категорию (добавьте маленькую 
кнопку «Подписаться», когда пользователь находится на странице новостей в какой-то категории).
https://disk.yandex.ru/d/9W5k894mFdUNOQ

Установка и настройка python-dotenv для хранения данных в переменных окружения:
https://disk.yandex.ru/d/1gSjj1gIQ-rnfg

pip install python-dotenv
В settings.py добавить:
from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv())

Итоговое задание 9.5.4 (HW-03)
+1. В категории должна быть возможность пользователей подписываться на рассылку новых статей в этой категории.
Если пользователь подписан на какую-либо категорию, то, как только в неё добавляется новая статья, 
её краткое содержание приходит пользователю на электронную почту, которую он указал при регистрации. 
В письме обязательно должна быть гиперссылка на саму статью, чтобы он мог по клику перейти и прочитать её.
+2. Если пользователь подписан на какую-либо категорию, то каждую неделю ему приходит на почту список новых 
статей, появившийся за неделю с гиперссылкой на них, чтобы пользователь мог перейти и прочесть любую из статей.
+3. Добавьте приветственное письмо пользователю при регистрации в приложении.

отправлять периодические письма - apscheduler 
https://apps.skillfactory.ru/learning/course/course-v1:SkillFactory+PDEV-D+2022/block-v1:SkillFactory+PDEV-D+2022+type@sequential+block@315c28aa957e4d65ba4972185db53708/block-v1:SkillFactory+PDEV-D+2022+type@vertical+block@753edf6c937847d0ae6a9e3e86dd50de
https://disk.yandex.ru/i/c82kI0uY5rMJJw

pip install django-apscheduler
python manage.py migrate
Добавить папку News_Portal/Models/commands и в ней создать файл runapscheduler.py
заполнить файл содержимым

запустим наш сервер:
python manage.py runserver
И в соседнем терминале выполним нашу команду:
python manage.py runapscheduler

*****************************************************************************
Продолжаем работать над проектом новостного приложения. В этом модуле мы, конечно же, добавим работу с асинхронными запросами. Для успешного выполнения этого итогового задания модуля вам необходимо:

+ Установить Redis.
+ Установить Celery.
+ Произвести необходимые конфигурации Django для соединения всех компонентов системы.
+ Реализовать рассылку уведомлений подписчикам после создания новости.
+ Реализовать еженедельную рассылку с последними новостями (каждый понедельник в 8:00 утра).
*****************************************************************************

worker — это часть системы, которая отправляет задачи из очереди на исполнение.

Все задачи принято хранить в файлах с названием tasks.py. В таком случае Celery сможет самостоятельно 
находить задачи. Любая задача представляет собой обычную функцию с одной особенностью: 
она должна быть обернута в декоратор.

1. Запустить сервер: 
(venv) PS C:\Project_News_Portal\News_Portal> python manage.py runserver

2. Запустить Redis

3. Запустить Celery:
(venv) PS C:\Project_News_Portal\News_Portal> celery -A News_Portal worker -l INFO --pool=solo

4. Запустить Beat:
(venv) PS C:\Project_News_Portal\News_Portal> Celery -A News_Portal beat -l INFO  

*****************************************************************************
Кэширование             https://docs.djangoproject.com/en/3.1/topics/cache/
+1. Добавьте кэширование на страницы с новостями (по 5 минут на каждую) и на главную страницу (одну минуту).

+2. В шаблонах постарайтесь кэшировать все навигационные элементы (меню, сайдбары и т. д.). 
Количество кэшируемого времени остаётся на ваше усмотрение. Кроме того, можете использовать 
любую систему кэширования, какая вам более по нраву.

3. Дополните свой новостной портал, добавьте кеширование для статей. 
Пока статья не изменилась, она должна сохраняться в кэше.
*****************************************************************************

3/8   D14.3. Команды для работы с базами данных

полная очистка базы данных> python manage.py flush
показать все изменения вносимые в базу данных> python manage.py showmigrations

+1. Выгрузите данные с вашего новостного сайта. Выгрузите только 
статьи
категории. 
Удалите все данные с вашего новостного сайта и попробуйте загрузить их с ранее созданной копии.

выгрузить все записи из БД в JSON-файл:
python manage.py dumpdata --format=json > mydata.json

в XML-формате:
python manage.py dumpdata --format=xml > mydata.xml

можно выгрузить данные из какого-то одного приложения, для этого достаточно добавить аргумент с названием приложения:
статьи
python manage.py dumpdata --format=json Models.post > posts_data.json
категории
python manage.py dumpdata --format=json Models.category > categ_backup.json

+2. Доработайте свой интернет-сервис. Напишите команду для manage.py, которая будет удалять все 
новости из какой-либо категории, но только при подтверждении действия в консоли при выполнении команды.

Создаем папки и команду
News_Portal\Models\management\commands\reset_posts_by_category.py

Для вызова команды удаления статей по категории, в консоли:
python manage.py reset_posts_by_category 'имя_категории'

********************************************************************************
Доработайте ваш новостной портал. Во все объекты добавьте удобный вывод и фильтры.
admin.py
********************************************************************************
Итоговое задание 16.4
Настоящие системы логирования очень распределенные и орудуют большим количеством связанных компонентов. 
Давайте попробуем создать подобный механизм. Ваши настройки логирования должны выполнять следующее:

1. В консоль должны выводиться все сообщения уровня DEBUG и выше, включающие время, уровень сообщения, 
    сообщения. Для сообщений WARNING и выше дополнительно должен выводиться путь к источнику события 
    (используется аргумент pathname в форматировании). А для сообщений ERROR и CRITICAL еще должен выводить 
    стэк ошибки (аргумент exc_info). Сюда должны попадать все сообщения с основного логгера django.

2. В файл general.log должны выводиться сообщения уровня INFO и выше только с указанием времени, 
    уровня логирования, модуля, в котором возникло сообщение (аргумент module) и само сообщение. 
    Сюда также попадают сообщения с регистратора django.

3. В файл errors.log должны выводиться сообщения только уровня ERROR и CRITICAL. В сообщении указывается время,
    уровень логирования, само сообщение, путь к источнику сообщения и стэк ошибки. 
    В этот файл должны попадать сообщения только из логгеров django.request, django.server, django.template, 
    django.db.backends.

4. В файл security.log должны попадать только сообщения, связанные с безопасностью, а значит только из логгера 
    django.security. Формат вывода предполагает время, уровень логирования, модуль и сообщение.

5. На почту должны отправляться сообщения уровней ERROR и выше из django.request и django.server по формату, 
    как в errors.log, но без стэка ошибок.

6. Более того, при помощи фильтров нужно указать, что в консоль сообщения отправляются только при 
    DEBUG = True, а на почту и в файл general.log — только при DEBUG = False.


